---
title: 程序员自我修养读书笔记
date: 2020-08-16 16:00:12
tags: 编译原理
---
链接，装载与库
<!--more-->


### 编译和链接

#### 预编译
预编译过程主要处理预处理源代码文件中的以“#”开始的预编译指令  

#### 编译
编译过程就是把预处理完的文件进行一系列词法分析，语法分析，语义分析以及优化后生成相应的汇编代码文件  
编译生成*.s文件  

#### 汇编
汇编器将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎对应一条机器指令  
汇编生成*.o中间目标文件  

#### 链接
链接是将将中间目标文件链接成可执行文件过程。链接过程包括`地址和空间分配`,`符号决议`, `重定位`等步骤  
链接将所有*.o中间目标文件链接成可执行文件*.out


### 目标文件介绍
#### 目标文件的格式
linux平台下目标文件格式为ELF(Executable Linkanle Format)格式类型。ELF文件标准里面把系统中采用的EFL格式  
的文件归位如下所举的4类  

| ELF文件类型  | 说明                                                         | 实例            |
| ------------ | ------------------------------------------------------------ | --------------- |
| 可重定位文件 | 这类文件包含代码和数据，可以被用来连接成可执行文件或共享目标文件，静态链接库也可以归为这一类 | *.o文件         |
| 可执行文件   | 这类文件包含可以直接执行的程序                               | /bin/bash的文件 |
| 共享目标文件 | 文件包含可以直接执行的程序，可以在以下两种情况使用。一种是链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件。第二种是动态链接器可以将这几个共享目标文件与可执行文件结合，作为进程映像的一部分运行 | *.so            |
| 核心转储文件 | 当进程意外终止时，系统可以将该进程地址空间的内容以及终止时的一些其他信息转储到核心转储文件中 | core dump       |

#### ELF文件结构

目标文件内容如下表格分布

**ELF表文件结构图**

**File Header**

描述整个文件属性，包括文件是否可执行、是静态链接还是动态链接以及入口地址、目标硬件、目标操作系统等信息

**.text. section**

程序源代码编译后的机器指令放在代码段（code section），也就是.txt段

**.data section**

已经初始化的全局变量和局部静态变量放在.data数据段

**.bss section**

未初始化的全局变量和静态变量放在.bss段中。未初始化的全局变量和静态变量默认值都为0，放在.data段分配空间并且存放数据0是没有必要的。程序运行的时候它们的确是要占用内存空间的，可执行文件必须记录所有未初始化的全局变量和静态变量的大小总和，记为.bss段。所有.bss段只是为未初始化的全局变量和静态变量预留位置，它并没有内容，在文件中也不占据空间  

**Section header table**（段表）

与段相关的重要结构，该表描述了ELF文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限以及段的其他属性。段表是以"Elf32_Shdr"结构体为元素的数组，Elf32_Shdr描述Elf文件中每个段（data，text，bss等）。

**.rel.text** （重定位表）

链接器在处理目标文件时，须要对目标文件中某些部位进行重定位，即代码段和数据段中对绝对地址的引用的位置。重定位的信息都记录在ELF文件的重定位表

**重定位表详细描述在下文**

**字符串表**

ELF文件中用到很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。字符串表将字符串集中起来存放到一个表，然后使用字符串在表中的偏移量引用字符串。字符串表分为字符串（String table）和段表字符串表（Section Header String Table）。字符串表用来保存普通的字符串，比如符号的名字；段表字符串表用来保存段表中用到的字符串，最常见的就是段名

Elf32_Shdr各个成员含义如表

| 成员             | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| sh_name          | 段名                                                         |
| sh_type          | 段类型                                                       |
| sh_flag          | 段标记位                                                     |
| sh_addr          | 段虚拟地址. 如果该段可以被加载，则sh_addr为该段被加载后在进程地址空间的虚拟地址；否则为0 |
| sh_offset        | 段偏移。如果该段存在于文件中，则表示该段在文件中的偏移；否则无意义 |
| sh_size          | 段的长度                                                     |
| sh_link和sh_info | 段的链接信息                                                 |
| sh_addralign     | 段地址对齐                                                   |
| sh_entsize       | 项的长度。有些段包含一些固定大小的项，比如符号表，它包含每个符号所占的大小都是一样的。对于这种段，sh_entsize表示每个项的大小。如果为0，则表示该段不包含固定大小的项 |

**代码段和数据段分开原因**

- 程序被装载之后，数据和指令分别映射到两个虚存区域。数据段对于程序来说是可读可写，指令区域对于进程来说是只读的，所以两个虚存空间的权限被分别设置为可读写和只读，可以防程序的指令被有意或无意地改写
- 指令区和数据区分离有利于提高程序的局部性。现代CPU的缓存一般都被设计成数据缓存和指令缓存分离，所以程序的指令和数据被分开存放对CPU的缓存命中率提高有好处
- 当系统运行多个程序的副本时，它们的指令都是一样的，所以内存中只须要保存一份该程序指令部分，可以节省大量的内存

#### 链接的接口--符号

链接是将多个目标文件链接成可执行文件过程。因为不同目标文件函数名或者变量名可能相同，因此链接过程中需要为函数名或者变量名设置独特的名字—符号名，把变量或者函数称为符号（symbol）。

##### 符号表和符号值

每个目标文件都会有相应的符号表（symbol table），符号表记录目标文件中所用到的所有符号。每个定义的符号有一个对应值，叫做符号值（Symbol Value），对于变量和函数来说，**符号值就是它们的地址**。

##### 符号类型

- 定义在本目标文件的全局符号，可以被其他目标文件引用
- 在本目标文件引用，但没有定义在本目标文件，一般叫做外部符号。比如"printf"符号
- 段名，编译器产生，它的值就是该段段起始地址
- 局部符号，这类符号只在编译单元内部可见
- 行号信息

##### ELF符号表结构

段名一般叫 .symtab

符号表是一个Elf32_Sym结构为元素的数组，每个Elf32_Sym结构对应一个符号，结构体内成员包括

| 成员     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| st_name  | 符号名                                                       |
| st_value | 符号值                                                       |
| st_size  | 符号大小。对于包含数据的符号，这个值是该数据类型大小。比如一个double型的符号它占用8个字节。 |
| st_info  | 符号类型和绑定信息。                                         |
| st_other |                                                              |
| st_shndx | 符号所在的段                                                 |
|          |                                                              |

**st_info**

| 宏定义     | 值   | 说明                               |
| ---------- | ---- | ---------------------------------- |
| STB_LOCAL  | 0    | 局部变量，对于目标文件的外部不可见 |
| STB_GLOBAL | 1    | 全局符号，外部可见                 |
| STB_WEAK   | 2    | 弱引用                             |
|            |      |                                    |

**弱符号与强符号**

多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候将会出现符号重复定义的错误。比如我们在目标文件A和目标文件B都定义全局整形变量global，并将它们初始化，那么链接器将A和B进行链接会报错：

```
b.o:(.data+0x0): multiple definition of `global`
a.o:(.data+0x0): first defined here
```

这种符号定义被称为强符号。

编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号

### 静态链接

#### 两步链接过程

第一步 **空间与地址分配** 扫描所有的输入目标文件，获得它们各个段的长度、属性和位置，并且将输入目标文件中的符号表所有的符号定义和符号引用收集起来，统一放到全局符号表。

第二步 **符号解析与重定位**	使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。

#### 空间与地址分配

**计算VMA**

链接前后程序所使用到的地址已经是程序在进程中的虚拟地址，即我们仅仅关心各个段中的VMA（Virtual Memory Address)，忽略文件偏移（File off）。链接之前，目标文件中所有段的VMA都是0，因为虚拟空间还没有分配，所以默认都为0.等到链接之后，可执行文件各个段都被分配到了相应的虚拟地址，VMA不为0.

**符号地址确定**

经过上面地址和空间分配之后，这时候输入文件中各个段在链接后的虚拟地址已经确定。因为各个符号在段内的相对位置是固定的，所以链接器为每个符号加上偏移量，使它们能够调整到正确的虚拟地址。

#### 符号解析与重定位

- 对于外部引用的符号，链接之前在本目标文件是不知道符号VMA。
- 由于不知道外部引用符号的VMA，所以在本目标文件中VMA地址暂时用假地址填充
- 链接过程中，需要查看 **重定位表** 来确定哪些符号需要重定位
- 链接器需要对某个符号的引用重定位时，确定这个符号的目标地址。链接器会查找所有输入目标文件的符号表组成的全局符号表，找到相应的符号进行重定位

##### 重定位表

重定位表结构专门用来保存这些与重定位相关的信息，用来描述如何修改相应的段内容（修改外部引用符号的VMA）。重定位表是以Elf32_Rel结构体为元素的数组，Elf32_Rel结构体成员为

| 成员     | 说明                   |
| -------- | ---------------------- |
| r_offset | 重定位 入口偏移        |
| r_info   | 重定位入口的类型和符号 |

##### 符号解析

重定位过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，让要确定这个符号的目标地址。这时候链接器会查找所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位

#### C++相关问题

#### 全局构造和析构

全局构造函数在main函数执行之前执行，全局析构函数在main函数之后执行

- .init 保存可执行指令，构成进程初始化代码。当一个程序开始运行时，在main函数之前调用
- .fini 保存进程终止代码指令。main函数之后执行

### 可执行文件的装载与进程

#### 进程虚拟地址空间

略略

#### 装载方式



### 动态链接

#### 动态链接原因

- 静态链接对计算机内存和磁盘空间浪费非常严重，在多进程情况下会保留多份静态库
- 静态链接对程序的更新、部署和发布会带来很多麻烦。更新静态库需要使用这个静态库的程序也跟着更新

#### 动态链接思想

是对那些组成程序目标文件的链接，等到程序运行时才进行链接，也就是把链接的过程推迟到运行时才进行，这就是动态链接的基本思想。

#### 动态链接带来的优化

- 节省内存和磁盘空间
- 方便更新静态库
- 由于多个程序共享静态库，减少物理页面换入换出时间，增加cpu缓存命中率

#### 动态库符号重定位

静态链接也讲过，对于弱符号，如果链接器必须确定所引用的函数，那么链接器会根据链接的规则将弱符号重定位。如果弱符号定义在一个动态共享库中，**那么链接器会将这个符号引用标记为一个动态链接符号，不对他进行重定位，而是把重定位的实际留到装载的时候再进行。**

#### 动态链接器

动态链接器是C语言库ld-.so. 动态链接器和普通的共享对象一样被映射到了进程的地址空间，系统开始运行程序之前，会把控制权给动态链接器，由动态链接器完成链接工作，之后再把控制权给程序

#### 地址无关代码

地址无关代码是为了解决指令部分在多个进程之间共享问题。重定位解决的是动态模块中有绝对地址引用的问题。

**固定装载地址的困扰**

共享对象在被装载时，如何确定它在进程虚拟空间的地址？早期共享库装载是通过固定装载地址来确定共享对象的VMA，这类共享对象即为静态共享库。静态共享库把程序各个模块交给操作系统来管理，操作系统在某个特定的地址划分出地址快，为已知的模块预留足够的空间

缺点：

1. 存在地址冲突问题
2. 升级之后共享库必须保持共享库中的全局函数和变量地址不变，一旦在链接的时候绑定了这些地址，更改之后就需要重新链接整个程序

#### 装载时重定位

在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时在完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序所有的绝对地址引用进程重定位。
静态链接时提到过重定位叫做**链接时重定位**。现在这种情况被称为**装载时重定位**

#### 地址无关代码

装载时重定位时解决动态模块中有绝对地址引用的办法之一，但它有一个很大的缺点就是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势。

为了解决上述问题，可以把指令部分需要被修改的部分分离出来，跟数据部分放一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案被称为**地址无关代码**。
模块中各种地址引用方式可以分为以下几种：

- 模块内部函数调用、跳转等。
- 模块内部的数据访问。
- 模块外部的函数调用、跳转等。
- 模块外部的数据访问。

##### 类型一 模块内部调用或跳转

模块内部的跳转、函数调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。

##### 类型二 模块内部数据访问

指令中不能直接包含数据的绝对地址，那么唯一的办法就是相对寻址。

##### 类型三 模块间数据访问

模块间的数据访问目标地址要等到装载时才决定。ELF的做法是在数据段里面建立一个**指向这些变量的指针数组**，也被称为**全局偏移表**，当代码需要引用该全局变量时，可以通过GOT中相对的项间接引用。

##### 类型四 模块间调用、跳转

GOT中相应的项保存的是目标函数的地址，当模块要调用目标函数时，可以通过GOT中的项进行间接跳转。

#### 延迟绑定（PLT）

动态链接有很多优势，比静态链接要灵活，但它牺牲了一部分性能代价：

1. 动态里链接对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址；
2. 对于模块间的调用也要向定位GOT，然后进行跳转。
3. 动态链接工作运行时完成，程序开始执行时，动态链接器都要进行一次链接。

改进：

在一个程序运行过程中，很多函数在程序执行完时都不会被用到，如果一开始把所有函数都链接好实际是一种浪费。

所有ELF采用一种叫做**延迟绑定**的做法，基本思想：当函数第一次被用到时才进行绑定，如果不用到，则不绑定。

#### 动态链接相关结构

#####  “.interp”段

“.interp”段的内容很简单，里面保存的就是一个字符串，这个字符串就是可执行文件所需要的动态链接器路径。

##### “.dynamic”段

这是动态链接ELF中最重要的结构，这个段里面保存了动态链接器所有需要的基本信息，比如：依赖与那些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。

“.dynamic”段可以看成动态链接器下ELF文件的文件头。

#### 动态链接步骤和实现

1. 启动动态链接器本身
2. 装载所有需要的共享对象
3. 重定位和初始化

##### 动态链接器自举

1. 动态链接器本身不可以依赖于其他任何共享对象；

2. 其次时动态链接器本身所需要的全局和静态变量的重定位工作由它本身完成

3. 编写动态链接器时保证不使用任何系统库、运行库；

4. 对于第二个条件动态链接器必须在启动时有一段代码可以完成这项工作同时又不能用到全局和静态变量。

   

   这种具有一定限制条件的启动代码往往被称为**自举**。

##### 装载共享对象

1. 动态链接器将可执行文件和链接器本身的符号表都合并到一个符号表中，我们称为**全局符号表**
2. 链接器开始寻找可执行文件所依赖的共享对象。在”.dynamic”段中，类型入口DT_NEEDED，它所指出的是该可执行文件所依赖的共享对象
3. 链接器可以列出可执行文件所需要的所有共享对象，并将这些共享对象的名字放入一个装载集合中
4. 链接器开始从集合里取一个所需要的共享对象名字，找到相对应的文件后打开该文件，读取相应的ELF文件头和”.dynalic”段，然后将它相应的代码段和数据段映射到进程空间
5. 当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有共享对象都被装载进来的时候，全局符号表里面将包含进程中所有的动态链接器所需要的符号

##### 重定位和初始化

链接器开始重新遍历可执行文件和每个共享对象的重定位表，将它们的GOT/PLT中每个需要重定位的位置进行修正。

重定位完成之后，如果某个共享对象有”.init”段，那么动态链接器会执行”.init”段中代码，用以实现共享对象特有的初始化过程






