---
title: redis设计简介
date: 2018-07-23 01:16:12
tags: 数据库 redis
---
redis 底层实现原理简介  
<!--more-->
### 多数据库

	redis是字典结构的存储服务器，一个redis实例提供多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。
	
	redis不支持自定数据库名字，每个数据库都以编号命名。另外，一个redis实例不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么链一个数据库页没有权限访问。最重要的多个数据库之间不是完全隔离的，比如flushall可以清空一个redis实例中所有数据库中的数据。

### 简单动态字符串SDS

```c++
struct sdshdr {
    // 记录buf数组中已经使用字节的数量
    //等于SDS所保存字符串长度
    int len;
    // 记录buf数组中未使用字节数量
    int free;
    //字节数组，用于保存字符串
    char buf[]
}
```

1. 使用len获取字符串长度
2. 空间预分配足够，减少修改字符串时带来的内存重分配次数
3. 惰性空间释放，字符串缩短操作不直接设计内存空间的释放。

### 链表

redis中的列表键是用链表实现的。当一个列表键中包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，redis就会使用链表作为列表键的底层实现。

### 字典

使用哈希表实现，一个哈希表里面有多个哈希表结点，而每个哈希表结点就保存了字典中的一个键值对。

1. 使用哈希链表解决冲突

2. rehash方式采用渐进式hash

   当哈希表中键值对数量太多后者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。

   哈希表扩展收缩时间：

   1. 服务器目前没有实行BGSAVE或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1.
   2. 服务器目前证字啊执行BGSAVE或者BGREWRITE命令，并且哈希表的负载因子大于等于5
   3. 负载因子小于0.1时哈希收缩。


### 跳跃表

跳跃表是一种有序的数据结构，它通过在每个结点中维持多个指向其他结点的指针，从而达到快速访问结点的目的。

Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，redis会使用跳跃表作为底层实现。

redis还在集群结点中把跳跃表作为内部数据结构。

### 整数集合

当一个几何中值包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。

```c++
typedef struct intset{
	//编码方式，确定数组存放的整数类型
	uint32_t encoding;
	//集合中包含的元素数量
	uint32_t length;
	//保存元素的数组
	int8_t contents[];
}intset
```

1. 升级。添加的新元素类型长度大于原来的整数集合元素，需要分配内存空间添加到原来的数组上，然后移动原来的元素至合适的位置。
2. 不存在降级操作。

### 压缩列表

压缩列表是列表键和哈希键的底层实现之一。当一个列表见只包含少量列表项，并且每个列表键要么就是小整数，要么就是长度比较短的字符串，那么Redis就会使用压缩列表作为底层实现。

压缩列表是为了节约内存开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个结点，每个结点可以保存一个字节数组或者一个整数值。

### 对象

| 类型常量     | 描述         |
| ------------ | ------------ |
| REDIS_STRING | 字符串对象   |
| REDIS_LIST   | 列表对象     |
| REDIS_HASH   | 哈希对象     |
| REDIS_SET    | 集合对象     |
| REDIS_ZSET   | 有序集合对象 |

### 内存回收

Redis对象使用引用计数实现内存回收机制

### 对象共享

Redis通过引用计数实现对象共享

### RDB持久化

Redis是内存数据库，他将自己的数据库状态存储在内存里面，redis退出需要将数据保存到磁盘里面。RDB提供了持久化功能。

1. SAVE命令有服务器进程直接执行保存操作，所以该命令会阻塞服务器
2. BGSAVE由子进程执行，不阻塞
3. 服务器状态中会保存save选项设置的保存条件，当任意一个条件被满足时，服务器会自动执行BGSAVE命令
4. RDB文件是一个经过压缩的二进制文件

### AOF持久化

RDB通过保存键值对来记录数据库，AOF是通过保存执行的写命令来记录数据库。

实现可以分为：命令追加（append)、文件写入、文件同步三个步骤。

命令追加：服务器执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。

文件写入与同步：通过设置appendfsysnc选项值来确定AOF文件写入和同步的频率

1. always服务器每个事件循环将aof_buf缓冲区中所有内容写入到AOF文件中
2. everysec：服务器每个事件循环都要将aof_buf缓冲区的所有内容写入到AOF文件中，并且每隔一秒就要在子线程中对AOF文件进行同步操作。
3. no：何时决定AOF同步由操作系统决定。

AOF文件载入与数据还原:


AOF重写：

解决AOF文件体积膨胀问题，根据原有的键值对来重写AOF文件，使得新的AOF文件不会包含任何浪费空间的冗余命令。

AOF后台重写：

AOF后台重写需要新开一个AOF重写区，重写完成后需要将缓冲区的内容添加到AOF文件末尾。

### 事件

redis是事件驱动程序，分为：文件事件、时间事件

文件事件：客户端请求

时间事件：redis定时操作


事件类型：AE_READABLE 	AE_WRITABLE

如果套接字同时产生两种事件，先读后写。

### 多机数据库技术

- 复制
- Sentinel
- 集群

### 复制

复制功能分为：

1. 同步

   主服务器将RDB文件和缓冲区保存的命令发给从服务器，属于完整重同步

2. 命令传播

   客户端发给主服务器的写命令，主服务器将命令传播给其他服务器，属部分重同步

命令传播PSYNC的实现：

1. 主服务器的复制偏移量和从服务器的复制偏移量，用来判定主从是否状态一致
2. 主服务器复制积压缓冲区，用来暂时保存主向从发送的命令，断线重连后可以发送未发送成功的命令
3. 服务器运行ID，如果重连后服务器运行ID改变，则采用完全重同步操作

复制的实现：

1. 设置主服务器的地址和端口
2. socket连接
3. 发送ping命令，检测网络连接。出错需要重连主服务器
4. 身份验证
5. 发送从服务器监听端口
6. 同步
7. 传播命令

心跳检测：

1. 检测网路连接。
2. 辅助实现min-slaves选项。
3. 检测命令丢失。通过主从服务器的偏移量来确定。

### Sentinel

Sentinel（哨岗、哨兵）是Redis高可用解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监听任意多个主服务器以及从服务器。当主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。

获取主服务器信息：

Sentinel默认会以每10秒一次 的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。

检测主观下线状态  --> 检测客观下线状态

Sentinel与服务器之间建立命令连接和订阅连接。 Sentinel之间则只有命令连接，获取新的Sentinel是通过服务器订阅信息获取。

故障转移：

领头Sentinel对已经下线的主服务器执行故障转移操作：

1. 从服务器选举获得主服务器
2. 修改从服务器的复制目标
3. 将旧的主服务器变为从服务器

### 

| 命令             | 说明                 |
| ---------------- | -------------------- |
| CLUSTER_MEET     | 建立集群             |
|                  | 传播节点的槽指派信息 |
| CLUSTER ADDSLOTS | 将输入的槽指派       |
| MIGRATE          | 重新分片             |
|                  | ASK错误处理          |
|                  |                      |

集群数据结构

clusterNode：保存了一个节点的当前状态

clusterLink：保存连接节点需要的信息，比如套接字和缓冲区

CLUSTER MEET命令：

节点之间通过该命令完成三次握手，建立连接

槽指派：

Redis集群通过分片的方式保存数据库中的键值对：集群的整个数据库被分为16384个槽，数据库中的每个键都属于这些槽的一个，集群中每个节点都可以处理0个或16384个槽。

当数据库中的16384个槽都有被处理时，处于上线状态；否则处于下线状态。

ASK错误处理：


ASKING命令：

当客户端接收到ASK错误并通过MOVED命令转向值正在导入槽的节点时，客户端会先向节点发送一个ASKING命令，然后才重新发送要执行的命令，如果没有ASKING命令，服务器会拒绝执行命令。

复制和故障转移：

主要通过从节点来恢复数据

故障检测：

集群每个节点会定期向其他节点发送ping消息，以此来检测对方是否在线，如果接收ping消息的节点没有在规定的时间内，向发送那个ping消息节点发送pong消息的节点，则会标记为疑似下线。当半数投票为疑似下线标记时，则会进一步升级标记为下线标记。

| 消息    | 说明             |
| ------- | ---------------- |
| MEET    | 加入集群         |
| PING    | 故障检测         |
| PONG    | 确认消息         |
| FALL    | 广播节点下线信息 |
| FUBLISH | 发布             |

### 发布与订阅

| 命令       | 说明     |
| ---------- | -------- |
| PUBLISH    | 发布     |
| SUBSCRIBE  | 订阅     |
| PSUBSCRIBE | 订阅模式 |

每当有其他客户端向被订阅的频道发布消息时，频道的所有订阅者都会收到这条消息。消息不仅会发送给这个频道的所有订阅者，还会发送给所有与这个频道相匹配的模式订阅者。

### 事务

| 命令  | 说明                 |
| ----- | -------------------- |
| MULTI | 事务开始             |
| EXEC  | 执行事务             |
| WATCH | 监视数据库键，乐观锁 |

事务实现：

1. 事务开始
2. 命令入队
3. 事务执行
